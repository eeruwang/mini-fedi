<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mini-fediview</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #0b0e12;
      --muted: rgba(0,0,0,0.55);
      --card: #f7f9fc;
      --border: rgba(0,0,0,0.08);
      --btn-bg: rgba(0,0,0,0.04);
      --btn-bg-hover: rgba(0,0,0,0.08);
      --link: #1b6fff;
    }
    :root[data-theme="dark"] {
      --bg: #0b0e12;
      --fg: #e6eef8;
      --muted: rgba(230,238,248,0.7);
      --card: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.08);
      --btn-bg: rgba(255,255,255,0.06);
      --btn-bg-hover: rgba(255,255,255,0.12);
      --link: #98c1ff;
    }
    @media (prefers-color-scheme: dark) {
      :root:not([data-theme]) {
        --bg: #0b0e12;
        --fg: #e6eef8;
        --muted: rgba(230,238,248,0.7);
        --card: rgba(255,255,255,0.06);
        --border: rgba(255,255,255,0.08);
        --btn-bg: rgba(255,255,255,0.06);
        --btn-bg-hover: rgba(255,255,255,0.12);
        --link: #98c1ff;
      }
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: var(--bg); color: var(--fg); }
    header { position: sticky; top: 0; background: color-mix(in oklab, var(--bg) 70%, transparent); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); border-bottom: 1px solid var(--border); z-index: 10; }
    .wrap { max-width: 840px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 8px; align-items: center; }
    .btn { padding: 8px 12px; border-radius: 10px; background: var(--btn-bg); border: 1px solid var(--border); color: var(--fg); cursor: pointer; }
    .btn:hover { background: var(--btn-bg-hover); }
    .pill { padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: var(--card); }
    .post { padding: 14px 16px; border-bottom: 1px solid var(--border); }
    .name { font-weight: 700; }
    .name img { height: 1em; width: auto; vertical-align: -0.15em; }
    .meta { opacity: .7; font-size: 12px; }
    .media img, .media video { max-width: 100%; border-radius: 10px; display: block; margin-top: 8px; }
    .reactions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 12px; padding-top: 6px; border-top: 1px solid var(--border); }
    .badge { display: inline-flex; align-items: center; gap: 6px; border: 1px solid var(--border); background: var(--card); border-radius: 999px; padding: 4px 8px; font-size: 12px; }
    .badge img { height: 1.1em; width: auto; vertical-align: -0.2em; border-radius: 3px; }
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .post-head { display:flex; gap:10px; align-items:center; margin-bottom:4px; }
    .avatar { width:42px; height:42px; border-radius:999px; object-fit:cover; background:#222; flex:0 0 42px; }
  </style>
</head>
<body>
<header>
  <div class="wrap row">
    <div class="row" style="gap:6px;">
      <button id="tab-home" class="btn">Home</button>
      <button id="tab-fav" class="btn">Favourites</button>
    </div>
    <div style="flex:1"></div>
    <div class="row">
      <span id="acct" class="pill">‚Ä¶</span>
      <button id="theme-toggle" class="btn" title="Toggle theme">üåô</button>
      <button id="logout" class="btn">Logout</button>
    </div>
  </div>
</header>

<main class="wrap" id="feed"></main>
<div id="sentinel" style="height:60px;"></div>

<script>
/* =========================
   Helpers (cookies / fetch)
   ========================= */
function getCookie(name) {
  const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([$?*|{}\]\\^])/g, '\\$1') + '=([^;]*)'));
  return m ? decodeURIComponent(m[1]) : '';
}
async function jfetch(url, opts = {}) {
  const r = await fetch(url, { credentials: 'include', ...opts });
  if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  return r.json();
}

/* =========================
   Theme toggle
   ========================= */
const THEME_KEY = 'theme';
function getPreferredTheme() {
  const saved = localStorage.getItem(THEME_KEY);
  if (saved === 'light' || saved === 'dark') return saved;
  return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}
function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  const btn = document.getElementById('theme-toggle');
  if (btn) btn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
}
function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme') || getPreferredTheme();
  const next = current === 'dark' ? 'light' : 'dark';
  localStorage.setItem(THEME_KEY, next);
  applyTheme(next);
}
applyTheme(getPreferredTheme());
try {
  const mql = window.matchMedia('(prefers-color-scheme: dark)');
  mql.addEventListener?.('change', e => {
    const saved = localStorage.getItem(THEME_KEY);
    if (saved !== 'light' && saved !== 'dark') applyTheme(e.matches ? 'dark' : 'light');
  });
} catch {}

/* =========================
   Emoji map (Misskey & Masto)
   ========================= */
const emojiMapCache = new Map(); // host -> [{name,url}]
async function getMisskeyEmojis(host) {
  if (!host) return [];
  if (emojiMapCache.has(host)) return emojiMapCache.get(host);
  try {
    const data = await jfetch(`/api/mk/meta?host=${encodeURIComponent(host)}`);
    const list = Array.isArray(data?.emojis) ? data.emojis : [];
    emojiMapCache.set(host, list);
    return list;
  } catch { return []; }
}
function buildMastoEmojiMap(status) {
  const all = [];
  if (Array.isArray(status?.emojis)) all.push(...status.emojis);
  if (Array.isArray(status?.account?.emojis)) all.push(...status.account.emojis);
  if (Array.isArray(status?.poll?.emojis)) all.push(...status.poll.emojis);
  const out = [];
  for (const e of all) {
    if (e && typeof e.shortcode === 'string' && typeof e.url === 'string') {
      out.push({ name: e.shortcode, url: e.url });
    }
  }
  const seen = new Set();
  return out.filter(e => (seen.has(e.name) ? false : (seen.add(e.name), true)));
}

/* =========================
   Emoji rendering
   ========================= */
function renderEmojisToHTML(textOrHTML, emojiList) {
  if (!textOrHTML || !emojiList?.length) return textOrHTML || '';
  let html = String(textOrHTML);
  for (const e of emojiList) {
    if (!e?.name || !e?.url) continue;
    const re = new RegExp(`:${e.name}:`, 'g');
    html = html.replace(
      re,
      `<img src="${e.url}" alt=":${e.name}:" style="height:1.2em;width:auto;vertical-align:-0.2em;aspect-ratio:auto;display:inline-block;">`
    );
  }
  return html;
}
function escapeHTML(s='') {
  return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
}

/* =========================
   Media rendering (Masto/Misskey)
   ========================= */
function renderMedia(post) {
  const media = Array.isArray(post?.media_attachments) ? post.media_attachments
               : Array.isArray(post?.files) ? post.files
               : [];
  if (!media.length) return '';
  const pieces = [];
  for (const m of media) {
    if (m?.type && (m.url || m.preview_url)) {
      if (m.type === 'image' || m.type === 'gifv') {
        pieces.push(`<img src="${m.preview_url || m.url}" loading="lazy" alt="" />`);
      } else if (m.type === 'video') {
        pieces.push(`<video src="${m.url}" controls playsinline></video>`);
      }
      continue;
    }
    if (m?.type && (m.url || m.thumbnailUrl)) {
      const isImage = String(m.type).startsWith('image/');
      if (isImage) pieces.push(`<img src="${m.thumbnailUrl || m.url}" loading="lazy" alt="" />`);
      else pieces.push(`<video src="${m.url}" controls playsinline></video>`);
      continue;
    }
    if (m?.url) pieces.push(`<img src="${m.url}" loading="lazy" alt="" />`);
  }
  return pieces.length ? `<div class="media">${pieces.join('')}</div>` : '';
}

/* =========================
   Post card rendering
   ========================= */
async function renderPostHTML(post, opts) {
  const { source } = opts; // 'masto' | 'misskey'

  if (source === 'masto') {
    const acc = post?.account || {};
    const displayName = acc.display_name || acc.username || '';
    const handle = acc.acct ? `@${acc.acct}` : '';
    const createdAt = post?.created_at || '';
    const avatarURL = acc.avatar_static || acc.avatar || '';
    const mastoEmojiMap = buildMastoEmojiMap(post);
    const contentHTML = renderEmojisToHTML(post?.content || '', mastoEmojiMap);
    const mediaHTML = renderMedia(post);
    const faves = post?.favourites_count ?? 0;
    const boosts = post?.reblogs_count ?? 0;
    const replies = post?.replies_count ?? 0;

    let reactionsHTML = '';
    if (Array.isArray(post?._mkReactions)) {
      const mkBadges = post._mkReactions.map(r => {
        if (r.url) return `<span class="badge"><img src="${r.url}" alt=":${r.name}:" />${r.count ?? ''}</span>`;
        return `<span class="badge">${r.name} ${r.count ?? ''}</span>`;
      }).join('');
      reactionsHTML += mkBadges;
    }
    reactionsHTML += `<span class="badge">üí¨ ${replies}</span><span class="badge">‚ô∫ ${boosts}</span><span class="badge">‚≠ê ${faves}</span>`;

    return `
      <article class="post">
        <div class="post-head">
          <img class="avatar" src="${avatarURL}" alt="" loading="lazy">
          <div>
            <div class="name">${renderEmojisToHTML(displayName, mastoEmojiMap)} <span class="meta">${handle}</span></div>
            <div class="meta">${new Date(createdAt).toLocaleString()}</div>
          </div>
        </div>
        <div class="content">${contentHTML}</div>
        ${mediaHTML}
        <div class="reactions">${reactionsHTML}</div>
      </article>
    `;
  }

  if (source === 'misskey') {
    const u = post?.user || {};
    const displayName = u.name || u.username || '';
    const handle = u.username ? `@${u.username}` : '';
    const createdAt = post?.createdAt || '';
    const avatarURL = u.avatarUrl || '';
    const host = getCookie('mk_host');
    const emojiList = await getMisskeyEmojis(host);
    const text = post?.text || '';
    const textHTML = renderEmojisToHTML(escapeHTML(text).replace(/\n/g, '<br>'), emojiList);
    const mediaHTML = renderMedia(post);

    const rx = post?.reactions || {};
    const rxBadges = [];
    if (rx && typeof rx === 'object') {
      for (const key of Object.keys(rx)) {
        const count = rx[key];
        const name = key.replace(/^:/, '').replace(/:$/, '');
        const em = emojiList.find(e => e.name === name);
        if (em?.url) rxBadges.push(`<span class="badge"><img src="${em.url}" alt=":${name}:" />${count}</span>`);
        else rxBadges.push(`<span class="badge">:${name}: ${count}</span>`);
      }
    }

    return `
      <article class="post">
        <div class="post-head">
          <img class="avatar" src="${avatarURL}" alt="" loading="lazy">
          <div>
            <div class="name">${renderEmojisToHTML(escapeHTML(displayName), emojiList)} <span class="meta">${handle}</span></div>
            <div class="meta">${new Date(createdAt).toLocaleString()}</div>
          </div>
        </div>
        <div class="content">${textHTML}</div>
        ${mediaHTML}
        <div class="reactions">${rxBadges.join('')}</div>
      </article>
    `;
  }

  return `<article class="post"><div class="content">Unsupported post</div></article>`;
}

/* =========================
   Timeline state & loaders
   ========================= */
const feedEl = document.getElementById('feed');
let mode = 'home'; // 'home' | 'fav'
let isLoading = false;
let cursor = null; // Masto: max_id, Misskey: untilId
let source = null; // 'masto' | 'misskey'
let activeHost = null;

async function loadMe() {
  try {
    const me = await jfetch('/api/me');
    source = 'masto';
    activeHost = getCookie('ap_inst') || '';
    document.getElementById('acct').textContent = me?.acct ? `@${me.acct}` : me?.username || 'Mastodon';
    return { source };
  } catch {
    const me = await jfetch('/api/mk/me');
    source = 'misskey';
    activeHost = getCookie('mk_host') || '';
    document.getElementById('acct').textContent = me?.username ? `@${me.username}` : 'Misskey';
    return { source };
  }
}

async function loadPage(initial=false) {
  if (isLoading) return;
  isLoading = true;
  try {
    const path = mode === 'fav'
      ? (source === 'masto' ? '/api/favourites' : '/api/mk/home?favourites=1')
      : (source === 'masto' ? '/api/home' : '/api/mk/home');

    const u = new URL(path, location.origin);
    if (cursor) {
      if (source === 'masto') u.searchParams.set('max_id', cursor);
      else u.searchParams.set('untilId', cursor);
    }
    const data = await jfetch(u.toString());
    const items = Array.isArray(data?.items) ? data.items : Array.isArray(data) ? data : [];
    for (const post of items) {
      const html = await renderPostHTML(post, { source });
      const div = document.createElement('div');
      div.innerHTML = html;
      feedEl.appendChild(div.firstElementChild);
    }
    if (source === 'masto') {
      cursor = data?.next_max_id || (items.length ? items[items.length - 1]?.id : null);
    } else {
      cursor = data?.next || (items.length ? items[items.length - 1]?.id : null);
    }
  } catch (e) {
    console.error(e);
  } finally {
    isLoading = false;
  }
}

/* =========================
   UI bindings
   ========================= */
document.getElementById('tab-home').addEventListener('click', async () => {
  mode = 'home'; cursor = null; feedEl.innerHTML = ''; await loadPage(true);
});
document.getElementById('tab-fav').addEventListener('click', async () => {
  mode = 'fav'; cursor = null; feedEl.innerHTML = ''; await loadPage(true);
});
document.getElementById('logout').addEventListener('click', async () => {
  try {
    if (source === 'masto') await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
    if (source === 'misskey') await fetch('/api/mk/logout', { method: 'POST', credentials: 'include' });
  } finally {
    location.href = '/';
  }
});
document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

// infinite scroll
new IntersectionObserver(async (entries) => {
  for (const e of entries) if (e.isIntersecting) await loadPage();
}, { rootMargin: '600px' }).observe(document.getElementById('sentinel'));

// init
(async function init() {
  await loadMe();
  await loadPage(true);
})();
</script>
</body>
</html>
