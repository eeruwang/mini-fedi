<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mini-fediview</title>
  <style>
    /* ====== Theme tokens ====== */
    :root {
      --bg: #ffffff;
      --fg: #0b0e12;
      --muted: rgba(0,0,0,0.55);
      --card: #f7f9fc;
      --border: rgba(0,0,0,0.08);
      --btn-bg: rgba(0,0,0,0.04);
      --btn-bg-hover: rgba(0,0,0,0.08);
      --link: #1b6fff;
      --shadow: 0 1px 2px rgba(0,0,0,0.04), 0 6px 24px rgba(0,0,0,0.06);
      --radius: 14px;
      --radius-sm: 10px;
      --radius-lg: 18px;
      --rx-font: 14px;
      --rx-pad-y: 8px;
      --rx-pad-x: 12px;
    }
    :root[data-theme="dark"] {
      --bg: #0b0e12;
      --fg: #e6eef8;
      --muted: rgba(230,238,248,0.7);
      --card: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.08);
      --btn-bg: rgba(255,255,255,0.06);
      --btn-bg-hover: rgba(255,255,255,0.12);
      --link: #98c1ff;
      --shadow: 0 1px 2px rgba(0,0,0,0.25), 0 6px 24px rgba(0,0,0,0.3);
    }
    @media (prefers-color-scheme: dark) {
      :root:not([data-theme]) {
        --bg: #0b0e12;
        --fg: #e6eef8;
        --muted: rgba(230,238,248,0.7);
        --card: rgba(255,255,255,0.06);
        --border: rgba(255,255,255,0.08);
        --btn-bg: rgba(255,255,255,0.06);
        --btn-bg-hover: rgba(255,255,255,0.12);
        --link: #98c1ff;
        --shadow: 0 1px 2px rgba(0,0,0,0.25), 0 6px 24px rgba(0,0,0,0.3);
      }
    }

    /* ====== Layout/Base ====== */
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: var(--bg); color: var(--fg); }
    header {
      position: sticky; top: 0;
      background: color-mix(in oklab, var(--bg) 72%, transparent);
      -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--border); z-index: 10;
    }
    .wrap { max-width: 840px; margin: 0 auto; padding: 12px 16px; }
    .row { display: flex; gap: 8px; align-items: center; }

    /* ====== Controls ====== */
    .btn {
      padding: 8px 12px; border-radius: var(--radius-sm);
      background: var(--btn-bg); border: 1px solid var(--border); color: var(--fg); cursor: pointer;
      transition: background .15s ease, transform .06s ease, box-shadow .15s ease;
    }
    .btn:hover { background: var(--btn-bg-hover); }
    .btn:active { transform: translateY(1px); }
    .pill {
      padding: 6px 10px; border: 1px solid var(--border);
      border-radius: 999px; background: var(--card);
    }

    /* ====== Mention chip ====== */
    .mention-chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:2px 8px;
      border:1px solid var(--border);
      background: color-mix(in oklab, var(--card) 92%, transparent);
      border-radius:999px;
      font-size: 13px;
      line-height: 1;
    }
    .mention-chip img{
      width:16px;
      height:16px;
      border-radius:999px;
      object-fit:cover;
      background:#222;
    }


    /* ====== Post card ====== */
    .post {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      /* 성능: 오프스크린 스킵 + 추정 높이 */
      content-visibility: auto;
      contain-intrinsic-size: 0 420px;
    }
    .post:first-child { border-top-left-radius: var(--radius); border-top-right-radius: var(--radius); }
    .post:last-child  { border-bottom-left-radius: var(--radius); border-bottom-right-radius: var(--radius); border-bottom: 1px solid var(--border); }

    .post.cardish {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin: 10px 0;
      border-bottom: none;
      transition: transform .06s ease, box-shadow .2s ease;
    }
    .post.cardish:hover { transform: translateY(-1px); box-shadow: 0 3px 6px rgba(0,0,0,.05), 0 14px 34px rgba(0,0,0,.08); }

    .post-head { display:flex; gap:10px; align-items:center; margin-bottom:6px; }
    .avatar { width:42px; height:42px; border-radius:999px; object-fit:cover; background:#222; flex:0 0 42px; }
    .name { font-weight: 700; font-size: 15px; line-height: 1.2; }
    .name img { height: 1em; width: auto; vertical-align: -0.15em; }
    .meta { opacity:.7; font-size: 12px; }

    /* ====== Content typography ====== */
    .content { line-height: 1.58; font-size: 15px; word-wrap: break-word; overflow-wrap: anywhere; }
    .content p { margin: 0.25em 0 0.6em; }
    .content p:first-child { margin-top: 0; }
    .content a { color: var(--link); text-decoration: underline; text-underline-offset: 2px; }
    .content a:hover { text-decoration-thickness: 2px; }
    .content blockquote {
      margin: .6em 0; padding: .6em .8em;
      border-left: 3px solid var(--border); background: color-mix(in oklab, var(--card) 80%, transparent);
      border-radius: var(--radius-sm);
    }
    .content code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: .92em; padding: .15em .4em; border-radius: 6px;
      background: color-mix(in oklab, var(--card) 86%, transparent);
      border: 1px solid var(--border);
    }
    .content pre {
      overflow-x:auto; padding: .8em; border-radius: var(--radius);
      background: color-mix(in oklab, var(--card) 90%, transparent);
      border: 1px solid var(--border);
    }
    .content img.emoji, .content img[alt^=":"][alt$=":"] {
      height: 1.2em; width: auto; vertical-align: -0.2em;
    }

    /* ====== Media grid ====== */
    .media { margin-top: 10px; }
    .media > * { display: block; width: 100%; border-radius: var(--radius); }
    .media:has(img:nth-child(1):last-child),
    .media:has(video:nth-child(1):last-child) { display: block; }
    .media:has(img:nth-child(2)),
    .media:has(video:nth-child(2)) {
      display: grid; gap: 8px; grid-template-columns: repeat(2, 1fr);
    }
    .media img, .media video {
      width: 100%; height: auto; border-radius: var(--radius);
      background: #000; object-fit: cover;
    }
    .media img:is(:only-child), .media video:is(:only-child) { aspect-ratio: 16/9; object-fit: cover; }
    @media (max-width: 520px) {
      .media:has(img:nth-child(3)), .media:has(video:nth-child(3)) { grid-template-columns: 1fr; }
    }

    /* ====== Reactions ====== */
    .reactions {
      display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
      margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border);
    }
    /* ✨ 리액션/액션 분리 레이아웃 */
    .rx-list   { display: flex; flex-wrap: wrap; gap: 8px; }
    .rx-actions{ display: flex; gap: 8px; margin-left: auto; }

    /* 리액션 칩 (크게 보이게) */
    .rx-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: var(--rx-pad-y) var(--rx-pad-x);
      font-size: var(--rx-font);
      line-height: 1;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: color-mix(in oklab, var(--card) 92%, transparent);
      cursor: default;            /* 클릭 아님 */
      user-select: none;
    }
    .rx-chip img {
      height: 1.4em;              /* 버튼보다 크게 */
      width: auto;
      vertical-align: -0.2em;
      border-radius: 3px;
    }
    .rx-chip:hover { background: var(--btn-bg-hover); }

    /* 액션 버튼(.badge) 크기 고정 – 리액션 확대와 분리 */
    .reactions .badge {
      font-size: 12px !important;
      padding: 6px 10px !important;
      line-height: 1 !important;
    }
    .reactions .badge img { height: 1.1em !important; }

    /* 기본 배지 스타일(댓글/부스트/좋아요) */
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      border: 1px solid var(--border);
      background: color-mix(in oklab, var(--card) 92%, transparent);
      border-radius: 999px; padding: 6px 10px;
      font-size: 12px; line-height: 1;
      transition: background .15s ease, transform .06s ease, border-color .15s ease;
    }
    .badge:hover { background: var(--btn-bg-hover); }
    .badge:active { transform: translateY(1px); }
    .badge img { height: 1.1em; width: auto; vertical-align: -0.2em; border-radius: 3px; }
    .like-btn[aria-pressed="true"] {
      background: color-mix(in oklab, var(--link) 12%, var(--card));
      border-color: color-mix(in oklab, var(--link) 25%, var(--border));
    }

    /* ====== Reblog/Boost ====== */
    .post.reblog { padding: 8px 16px 14px; background: transparent; border-bottom: 1px solid var(--border); }
    .reblog-banner {
      display:flex; align-items:center; gap:8px;
      font-size:12px; opacity:.75; margin: 4px 0 8px;
    }
    .reblog-banner .icon { transform: rotate(0turn); }
    .reblog-inner {
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: var(--radius);
      padding: 12px; position: relative; box-shadow: var(--shadow);
    }
    .reblog-inner::before {
      content: ""; position: absolute; left: 0; top: 10px; bottom: 10px;
      width: 3px; border-radius: 3px; background: var(--border);
    }
    .reblog-inner .post-head { margin-bottom: 4px; }
    .reblog-inner .name { font-weight: 700; }
    .reblog-inner .content { margin-top: 6px; }

    /* ====== Header account chip ====== */
    .acct { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; }
    .acct .avatar-mini, #acct-avatar {
      width: 18px; height: 18px; border-radius: 999px; object-fit: cover; background: #222;
    }

    /* ====== Thread (replies) ====== */
    .thread {
      margin-top: 8px; padding-left: 14px;
      border-left: 2px solid var(--border);
      animation: fadeIn .18s ease;
    }
    @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }
    .thread .post { background: none; border-bottom: 1px dashed var(--border); padding-left: 0; }
    .thread .post:last-child { border-bottom: 0; }

    /* ====== Links/Focus ====== */
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }
    :focus-visible { outline: 2px solid color-mix(in oklab, var(--link) 60%, transparent); outline-offset: 2px; }

    /* ====== Link card ====== */
    .link-cards { margin-top: 10px; display: grid; gap: 8px; }
    .link-card {
      display: grid; grid-template-columns: 96px 1fr; gap: 10px;
      border: 1px solid var(--border); background: var(--card);
      border-radius: var(--radius-sm); padding: 10px; box-shadow: var(--shadow);
      text-decoration: none; color: inherit;
    }
    .link-card:hover { background: color-mix(in oklab, var(--card) 85%, transparent); }
    .link-card .thumb {
      width: 96px; height: 96px; border-radius: 8px; background: #000;
      object-fit: cover;
    }
    .link-card .meta { font-size: 12px; opacity: .75; }
    .link-card .title { font-weight: 700; line-height: 1.25; margin-bottom: 4px; }
    .link-card .desc { font-size: 13px; line-height: 1.35; opacity:.85 }

    /* ====== Utilities ====== */

    .muted { 
      color: var(--muted); 
    }
    /* === Mentions in content: chip look → neutral link chip === */
    .content .mention-chip{
      border-color: var(--border);
      background: transparent;           /* 버튼 느낌 제거 */
      padding: 2px 6px;
    }
    .content a.mention-chip{
      text-decoration: none; color: inherit;
    }
    .content a.mention-chip:hover{
      background: color-mix(in oklab, var(--card) 80%, transparent);
    }

    /* 멘션 옆 "댓글" 미니 링크 */
    .mention-reply{
      font-size: 12px;
      opacity: .75;
      margin-left: 6px;
      text-decoration: underline;
      text-underline-offset: 2px;
      cursor: pointer;
    }
    .mention-reply:hover{ opacity: 1; }

    /* 댓글 컴포저(슬라이드 다운) */
    .composer {
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transition: max-height .28s ease, opacity .28s ease;
      border-top: 1px dashed var(--border);
      margin-top: 8px;
    }
    .composer.open {
      max-height: 260px;   /* 필요시 조절 */
      opacity: 1;
    }
    .reply-form { padding-top: 10px; }
    .reply-form textarea{
      width: 100%;
      min-height: 86px;
      resize: vertical;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg);
      padding: 10px 12px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .reply-form .row{ display:flex; gap:8px; margin-top:8px; align-items:center; }


    .user-chip .avatar-mini,
    .reblog-banner .avatar-mini {
      width: 16px; height: 16px; border-radius: 999px; object-fit: cover; background: #222; flex: 0 0 16px; aspect-ratio: 1 / 1;
    }
    .post.slide-enter { transform: translateY(-14px); opacity: 0; }
    .post.slide-enter-active { transform: translateY(0); opacity: 1; transition: transform .28s ease, opacity .28s ease; }
    .new-spacer { height: 0px; transition: height .28s ease; }

    .likers { overflow: hidden; margin-top: 8px; border-top: 1px dashed var(--border); padding-top: 8px; animation: fadeIn .18s ease; }
    .likers-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 8px; }
    .liker-chip { display: flex; align-items: center; gap: 8px; border: 1px solid var(--border); background: color-mix(in oklab, var(--card) 96%, transparent); border-radius: var(--radius-sm); padding: 6px 8px; }
    .liker-chip img { width: 28px; height: 28px; border-radius: 999px; object-fit: cover; background: #222; }
    .liker-chip .txt { line-height: 1.2; }
    .liker-chip .txt .meta { display:block; font-size: 12px; opacity:.7; }
  </style>

</head>
<body>
<header>
  <div class="wrap row">
    <div class="row" style="gap:6px;">
      <button id="tab-home" class="btn">Home</button>
      <button id="tab-fav" class="btn">Favourites</button>
    </div>
    <div style="flex:1"></div>
    <div class="row">
      <button id="acct-btn" class="pill acct" title="내 글 보기">
        <img id="acct-avatar" class="avatar-mini" alt="" />
        <span id="acct-name">…</span>
      </button>
      <button id="theme-toggle" class="btn" title="Toggle theme">🌙</button>
      <button id="logout" class="btn">Logout</button>
    </div>
  </div>
</header>

<main class="wrap" id="feed"></main>
<div id="sentinel" style="height:60px;"></div>

<script>
/* =========================
   Helpers (cookies / fetch)
   ========================= */
function getCookie(name) {
  const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([$?*|{}\]\\^])/g, '\\$1') + '=([^;]*)'));
  return m ? decodeURIComponent(m[1]) : '';
}
async function jfetch(url, opts = {}) {
  const r = await fetch(url, { credentials: 'include', ...opts });
  if (!r.ok) {
    const text = await r.text().catch(() => '');
    const err = new Error(`${r.status} ${r.statusText}`);
    err.status = r.status; err.body = text;
    throw err;
  }
  const ct = r.headers.get('content-type') || '';
  return ct.includes('application/json') ? r.json() : r.text();
}
const likersCache = new Map(); // id -> HTML

/* ===== 비동기 우선순위/동시성 유틸 ===== */
function defer(fn) {
  if (window.requestIdleCallback) return requestIdleCallback(() => fn(), { timeout: 1200 });
  return setTimeout(fn, 0);
}
const REACTION_QUEUE = [];
let REACTION_ACTIVE = 0;
const REACTION_MAX_CONCURRENCY = 3;
function scheduleReactionTask(task) {
  REACTION_QUEUE.push(task);
  pumpReactionQueue();
}
function pumpReactionQueue() {
  while (REACTION_ACTIVE < REACTION_MAX_CONCURRENCY && REACTION_QUEUE.length) {
    const t = REACTION_QUEUE.shift();
    REACTION_ACTIVE++;
    defer(async () => {
      try { await t(); } catch {}
      REACTION_ACTIVE--;
      pumpReactionQueue();
    });
  }
}

/* ===== 링크 프리뷰(OG) 큐/캐시 & 카드 생성기 ===== */

// 프론트 메모리 캐시: 같은 URL은 재사용
const linkPreviewCache = new Map(); // url -> HTML

// 링크 카드 비동기 큐 (리액션 큐와 동일 패턴)
const LINK_QUEUE = [];
let LINK_ACTIVE = 0;
const LINK_MAX_CONCURRENCY = 3;

function scheduleLinkTask(task) {
  LINK_QUEUE.push(task);
  pumpLinkQueue();
}
function pumpLinkQueue() {
  while (LINK_ACTIVE < LINK_MAX_CONCURRENCY && LINK_QUEUE.length) {
    const t = LINK_QUEUE.shift();
    LINK_ACTIVE++;
    defer(async () => {
      try { await t(); } catch {}
      LINK_ACTIVE--;
      pumpLinkQueue();
    });
  }
}

// 본문 HTML에서 <a href> 추출 (Mastodon)
function extractLinksFromHTML(html='') {
  const out = new Set();
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  tmp.querySelectorAll('a[href]').forEach(a => {
    const href = a.getAttribute('href') || '';
    if (/^https?:\/\//i.test(href)) out.add(href);
  });
  return Array.from(out);
}

// 평문 텍스트에서 URL 추출 (Misskey)
function extractLinksFromText(text='') {
  const out = new Set();
  const re = /\bhttps?:\/\/[^\s<>"']+/gi;
  let m; while ((m = re.exec(text))) out.add(m[0]);
  return Array.from(out);
}

// 스켈레톤 카드 (빠르게 자리만)
function renderLinkCardSkeleton(url) {
  try { new URL(url); } catch { return ''; }
  const u = new URL(url);
  const host = u.host.replace(/^www\./,'');
  return `
    <a class="link-card" href="${url}" target="_blank" rel="noopener noreferrer nofollow">
      <div style="width:96px;height:96px;border-radius:8px;background:var(--btn-bg);"></div>
      <div>
        <div class="meta">${host}</div>
        <div class="title" style="height:1.2em;background:var(--btn-bg);border-radius:4px;margin:4px 0;"></div>
        <div class="desc" style="height:2.6em;background:var(--btn-bg);border-radius:4px;"></div>
      </div>
    </a>`;
}

// 최종 카드 HTML
function renderLinkCardHTML(meta) {
  const u = new URL(meta.finalUrl || meta.url);
  const host = (meta.site || u.host.replace(/^www\./,'')).toString();
  const title = meta.title || u.hostname;
  const desc = meta.desc || '';
  const image = meta.image || meta.favicon || '';

  return `
    <a class="link-card" href="${meta.finalUrl || meta.url}" target="_blank" rel="noopener noreferrer nofollow">
      ${image ? `<img class="thumb" src="${image}" alt="" loading="lazy" decoding="async" fetchpriority="low">`
              : `<div class="thumb" style="background:var(--btn-bg)"></div>`}
      <div>
        <div class="meta">${escapeHTML(host)}</div>
        <div class="title">${escapeHTML(title)}</div>
        ${desc ? `<div class="desc">${escapeHTML(desc)}</div>` : ``}
      </div>
    </a>`;
}

/**
 * attachLinkCards:
 *  - 스켈레톤을 먼저 반환 → DOM에 붙은 뒤
 *  - scheduleLinkTask로 /api/og 호출 후 실제 카드로 교체
 *  - source: 'masto' | 'misskey'
 *  - contentHTML: masto의 본문 HTML(이모지 렌더 후)
 */
async function attachLinkCards({ base, post, source, contentHTML }) {
  const urls = new Set();

  if (source === 'masto') {
    // 1) 본문 <a>에서 추출
    extractLinksFromHTML(contentHTML).forEach(u => urls.add(u));
    // 2) 마스토든 status.card가 있으면 우선 추가
    const st = base || post || {};
    if (st.card && st.card.url) urls.add(st.card.url);
  }

  if (source === 'misskey') {
    const text = (post?.text || '').toString();
    extractLinksFromText(text).forEach(u => urls.add(u));
  }

  if (!urls.size) return ''; // 링크 없으면 아무 것도 안 붙임

  // 렌더 대상 컨테이너 id
  const wrapId = `lk-${(base?.id || post?.id || Math.random()).toString()}`;

  // 스켈레톤 먼저
  const skeleton = `<div class="link-cards" id="${wrapId}">
    ${Array.from(urls).map(u => linkPreviewCache.get(u) || renderLinkCardSkeleton(u)).join('')}
  </div>`;

  // 후순위로 OG 로딩해서 교체
  scheduleLinkTask(async () => {
    const el = document.getElementById(wrapId);
    if (!el) return;

    const metas = await Promise.all(Array.from(urls).map(async (u) => {
      if (linkPreviewCache.has(u)) return { url: u, html: linkPreviewCache.get(u) };
      try {
        const meta = await jfetch(`/api/og?url=${encodeURIComponent(u)}`);
        if (meta?.ok) {
          const html = renderLinkCardHTML(meta);
          linkPreviewCache.set(u, html);
          return { url: u, html };
        }
      } catch {}
      // 실패 시 스켈레톤 유지
      return { url: u, html: renderLinkCardSkeleton(u) };
    }));

    el.innerHTML = metas.map(m => m.html).join('');
  });

  return skeleton;
}


document.addEventListener('click', async (ev) => {
  const btn = ev.target.closest('.likers-toggle');
  if (!btn) return;

  const id = btn.dataset.id;
  if (!id) return;

  const article = btn.closest('article');
  let box = article?.querySelector(`.likers[data-for="${CSS.escape(id)}"]`);
  if (!box) return;

  if (!box.hasAttribute('hidden')) {
    box.setAttribute('hidden', '');
    btn.title = 'Show who liked';
    return;
  }

  if (likersCache.has(id)) {
    box.innerHTML = likersCache.get(id);
    box.removeAttribute('hidden');
    btn.title = 'Hide likers';
    return;
  }

  box.innerHTML = `<div class="meta">불러오는 중…</div>`;
  box.removeAttribute('hidden');
  btn.title = 'Hide likers';

  try {
    const users = await jfetch(`/api/status/favourited_by?id=${encodeURIComponent(id)}`);
    const list = Array.isArray(users) ? users : [];

    if (!list.length) {
      box.innerHTML = `<div class="meta">아직 좋아요가 없습니다.</div>`;
      likersCache.set(id, box.innerHTML);
      return;
    }

    const chips = list.map(u => {
      const name = (u.display_name || u.username || '').toString();
      const handle = u.acct ? `@${u.acct}` : '';
      const ava = u.avatar_static || u.avatar || '';
      return `
        <div class="liker-chip">
          <img src="${ava}" alt="" loading="lazy" decoding="async" fetchpriority="low" />
          <div class="txt">
            <strong>${escapeHTML(name)}</strong>
            <span class="meta">${escapeHTML(handle)}</span>
          </div>
        </div>`;
    }).join('');

    box.innerHTML = `<div class="likers-list">${chips}</div>`;
    likersCache.set(id, box.innerHTML);

  } catch (e) {
    console.error('likers fetch error', e);
    box.innerHTML = `<div class="meta">목록을 불러오지 못했습니다.</div>`;
  }
});

/* =========================
   Theme toggle
   ========================= */
const THEME_KEY = 'theme';
function getPreferredTheme() {
  const saved = localStorage.getItem(THEME_KEY);
  if (saved === 'light' || saved === 'dark') return saved;
  return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}
function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  const btn = document.getElementById('theme-toggle');
  if (btn) btn.textContent = theme === 'dark' ? '☀️' : '🌙';
}
function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme') || getPreferredTheme();
  const next = current === 'dark' ? 'light' : 'dark';
  localStorage.setItem(THEME_KEY, next);
  applyTheme(next);
}
applyTheme(getPreferredTheme());
try {
  const mql = window.matchMedia('(prefers-color-scheme: dark)');
  mql.addEventListener?.('change', e => {
    const saved = localStorage.getItem(THEME_KEY);
    if (saved !== 'light' && saved !== 'dark') applyTheme(e.matches ? 'dark' : 'light');
  });
} catch {}

/* ===== Mentions & Link-card helpers ===== */

/** mastodon/misskey 프로필 URL 패턴인지 판별 */
function isAccountProfileURL(href) {
  try {
    const u = new URL(href, location.origin);
    // /@name  혹은  /users/ID  같은 프로필 경로
    return /^\/@[^/]+\/?$/.test(u.pathname) || /^\/users\/[^/]+\/?$/.test(u.pathname);
  } catch { return false; }
}

/** a 요소가 멘션(계정 링크)인지 판별 */
function isMentionAnchor(a) {
  const href = a.getAttribute('href') || '';
  const txt = (a.textContent || '').trim();
  if (a.classList?.contains('mention')) return true;
  if (txt.startsWith('@')) return true;
  if (isAccountProfileURL(href)) return true;
  return false;
}

/** HTML 문자열에서 a들을 순회하면서 (1) 멘션은 칩으로 교체 (2) “외부 링크”만 수집 */
function transformContentAndCollectExternalLinks(html, post, source) {
  const tpl = document.createElement('template');
  tpl.innerHTML = html;
  const root = tpl.content;

  // Mastodon의 mentions 배열 사용(표시이름/아바타 매칭용)
  const mentionsMeta = source === 'masto' && Array.isArray(post?.mentions) ? post.mentions : [];

  /** 멘션 칩 만들기 */
  function makeMentionChip(a) {
    // 기본값
    let display = (a.textContent || '').replace(/^@/, '');
    let avatar = '';
    let acctUrl = a.getAttribute('href') || '';
    let acct = '';

    // mentions 메타로 보강
    if (mentionsMeta.length) {
      const hit = mentionsMeta.find(m =>
        (m?.url && acctUrl && m.url === acctUrl) ||
        (m?.acct && (a.textContent||'').includes(m.acct)) ||
        (m?.username && (a.textContent||'').includes(m.username))
      );
      if (hit) {
        display = hit.display_name || hit.username || display;
        avatar  = hit.avatar_static || hit.avatar || '';
        acctUrl = hit.url || acctUrl || '';
        acct    = hit.acct || (hit.username ? `${hit.username}${(() => { try{ const u=new URL(hit.url); return '@'+u.host; }catch{return ''} })()}` : '');
      }
    }

    // 칩을 a로(프로필 이동), 버튼 느낌 X
    const chip = document.createElement('a');
    chip.className = 'mention-chip';
    if (acctUrl) {
      chip.href = acctUrl; chip.target = '_blank'; chip.rel = 'noopener noreferrer';
    }
    if (acct) chip.dataset.acct = acct.startsWith('@') ? acct : ('@' + acct);
    chip.innerHTML = `${avatar ? `<img src="${avatar}" alt="" loading="lazy" decoding="async" fetchpriority="low">` : ''}<span>${escapeHTML(display)}</span>`;

    // 멘션 옆에 "댓글" 소링크(클릭 시 컴포저 열고 @계정 미리 채워줌)
    const reply = document.createElement('a');
    reply.href = '#';
    reply.className = 'mention-reply';
    reply.textContent = '댓글';
    reply.dataset.replyAcct = chip.dataset.acct || (a.textContent || '').trim();

    a.replaceWith(chip);
    chip.after(reply);
  }


  const externalLinks = [];
  root.querySelectorAll('a[href]').forEach(a => {
    const href = a.getAttribute('href') || '';
    // 멘션이면 칩으로 교체하고, 링크카드 대상에서 제외
    if (isMentionAnchor(a)) {
      makeMentionChip(a);
      return;
    }
    // 외부 http/https 링크만 카드 후보로
    if (/^https?:\/\//i.test(href)) {
      externalLinks.push(href);
    }
  });

  // HTML 재조립
  const outHTML = root.childNodes.length
    ? Array.from(root.childNodes).map(n => n.outerHTML || n.textContent).join('')
    : html;

  return { html: outHTML, externalLinks };
}

// === Misskey 멘션 → 아바타 칩화 ===
const mentionProfileCache = new Map(); // "user@host" -> { display, avatar }

/** 평문(@u@h)을 <span class="mention-chip" data-user data-host>로 치환(아바타는 나중에 주입) */
function chipifyPlainMentions(html='') {
  return html.replace(
    /(^|\s)@([a-z0-9_\.]+)@([a-z0-9\.\-]+)\b/gi,
    (m, pre, user, host) =>
      `${pre}<span class="mention-chip" data-user="${user}" data-host="${host}"><span>${user}</span></span>`
  );
}

/** 서버 프록시로 프로필 해오고(성공 시) 표시이름/아바타 리턴 */
async function resolveMisskeyProfile(user, host) {
  const key = `${user}@${host}`.toLowerCase();
  if (mentionProfileCache.has(key)) return mentionProfileCache.get(key);

  // ⚠️ 백엔드에 맞춰 경로 수정하세요. (예: /api/mk/user?username=&host=)
  try {
    const data = await jfetch(`/api/mk/user?username=${encodeURIComponent(user)}&host=${encodeURIComponent(host)}`);
    const res = {
      display: (data?.name || data?.username || user) + '',
      avatar: (data?.avatarUrl || data?.avatar || '') + ''
    };
    mentionProfileCache.set(key, res);
    return res;
  } catch {
    const res = { display: user, avatar: '' };
    mentionProfileCache.set(key, res);
    return res;
  }
}

/** content 컨테이너 안의 mention-chip들을 아바타/표시이름으로 수화(hydrate) */
async function hydrateMisskeyMentions(containerId) {
  const root = document.getElementById(containerId);
  if (!root) return;
  const chips = root.querySelectorAll('.mention-chip[data-user][data-host]');
  await Promise.all(Array.from(chips).map(async chip => {
    if (chip.dataset.hydrated === '1') return;
    const user = chip.getAttribute('data-user') || '';
    const host = chip.getAttribute('data-host') || '';
    const prof = await resolveMisskeyProfile(user, host);
    chip.innerHTML =
      `${prof.avatar ? `<img src="${prof.avatar}" alt="" loading="lazy" decoding="async" fetchpriority="low">` : ''}` +
      `<span>${escapeHTML(prof.display)}</span>`;
    chip.dataset.hydrated = '1';
    // hydrateMisskeyMentions 마지막에 추가
    const r = document.createElement('a');
    r.href = '#';
    r.className = 'mention-reply';
    r.textContent = '댓글';
    r.dataset.replyAcct = '@' + user + (host ? '@' + host : '');
    chip.after(r);

  }));
}


/* =========================
   Emoji map & resolution (Misskey & Masto)
   ========================= */
const emojiMapCache = new Map();      // host -> [{name,url}]
const emojiMapPromise = new Map();    // host -> Promise
const emojiIndexCache = new Map();    // host -> { byExact: Map, byLower: Map }
const resolvedEmojiCache = new Map(); // key(hostsKey|nameLower) -> url (간단 LRU)

/* ---- utils ---- */
function escapeRegExp(s='') { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
function normHost(h=''){ return String(h).replace(/^https?:\/\//,'').replace(/\/+$/,'').toLowerCase(); }
function eqCaseInsensitive(a,b){ return String(a||'').toLowerCase() === String(b||'').toLowerCase(); }

function escapeHTML(s='') {
  return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[ch]));
}

// ':name@host:' | ':name:' | 'name@host' | 'name' | '❤'
function parseQualifiedEmoji(raw = '') {
  let s = String(raw).trim();
  if (!s) return { name: null, host: null, char: null };

  // 유니코드 단일 이모지(간단 판정)
  if (!s.includes(':') && !s.includes('@') && s.length <= 2 && /\p{Extended_Pictographic}/u.test(s)) {
    return { name: null, host: null, char: s };
  }
  s = s.replace(/^:/, '').replace(/:$/, '');
  const at = s.indexOf('@');
  if (at > 0) return { name: s.slice(0, at), host: s.slice(at + 1).replace(/^https?:\/\//, '').replace(/\/+$/, ''), char: null };
  return { name: s, host: null, char: null };
}

/* ---- misskey emoji list fetch (via backend proxy) ---- */
const EMOJI_LS_PREFIX = 'mkEmoji:v1:';
const EMOJI_LS_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7일

function lsLoadEmoji(host) {
  try {
    const raw = localStorage.getItem(EMOJI_LS_PREFIX + host);
    if (!raw) return null;
    const data = JSON.parse(raw);
    if (!data || !data.t || !Array.isArray(data.list)) return null;
    if (Date.now() - data.t > EMOJI_LS_TTL_MS) return null;
    return data.list;
  } catch { return null; }
}
function lsSaveEmoji(host, list) {
  try {
    localStorage.setItem(EMOJI_LS_PREFIX + host, JSON.stringify({ t: Date.now(), list }));
  } catch {}
}

async function getMisskeyEmojis(host) {
  if (!host) return [];
  host = normHost(host);

  if (emojiMapCache.has(host)) return emojiMapCache.get(host);
  if (emojiMapPromise.has(host)) return emojiMapPromise.get(host);

  const cached = lsLoadEmoji(host);
  if (cached) {
    const byExact = new Map(), byLower = new Map();
    for (const e of cached) { byExact.set(e.name, e); byLower.set(e.name.toLowerCase(), e); }
    emojiIndexCache.set(host, { byExact, byLower });
    emojiMapCache.set(host, cached);
    return cached;
  }

  const p = jfetch(`/api/mk/emoji?host=${encodeURIComponent(host)}`)
    .then(data => {
      const map = data?.map || {};
      const list = Object.entries(map).map(([name, v]) => ({
        name,
        url: (v && (v.static_url || v.url)) || null
      })).filter(e => e.url);

      const byExact = new Map(), byLower = new Map();
      for (const e of list) { byExact.set(e.name, e); byLower.set(e.name.toLowerCase(), e); }
      emojiIndexCache.set(host, { byExact, byLower });

      emojiMapCache.set(host, list);
      lsSaveEmoji(host, list);

      emojiMapPromise.delete(host);
      return list;
    })
    .catch(() => { emojiMapPromise.delete(host); return []; });

  emojiMapPromise.set(host, p);
  return p;
}

/* ---- mastodon custom emoji map for names in content/display_name ---- */
function buildMastoEmojiMap(status) {
  const all = [];
  if (Array.isArray(status?.emojis)) all.push(...status.emojis);
  if (Array.isArray(status?.account?.emojis)) all.push(...status.account.emojis);
  if (Array.isArray(status?.poll?.emojis)) all.push(...status.poll.emojis);
  const out = [];
  for (const e of all) {
    if (e && typeof e.shortcode === 'string' && typeof e.url === 'string') {
      out.push({ name: e.shortcode, url: e.url });
    }
  }
  const seen = new Set();
  return out.filter(e => (seen.has(e.name) ? false : (seen.add(e.name), true)));
}

/* ---- content emoji replacer ---- */
function renderEmojisToHTML(textOrHTML, emojiList) {
  if (!textOrHTML || !emojiList?.length) return textOrHTML || '';
  let html = String(textOrHTML);
  for (const e of emojiList) {
    if (!e?.name || !e?.url) continue;
    const re = new RegExp(`:${escapeRegExp(e.name)}:`, 'g');
    html = html.replace(
      re,
      `<img src="${e.url}" alt=":${e.name}:" loading="lazy" decoding="async" fetchpriority="low"
             style="height:1.2em;width:auto;vertical-align:-0.2em;aspect-ratio:auto;display:inline-block;">`
    );
  }
  return html;
}

/* ---- resolve helpers ---- */
async function resolveMisskeyEmojiURLByHost(hostCandidate, nameOrQualified) {
  const parsed = parseQualifiedEmoji(nameOrQualified);
  if (parsed.char) return null;
  const name = parsed.name;
  const host = normHost(parsed.host || hostCandidate || '');
  if (!host || !name) return null;

  await getMisskeyEmojis(host);
  const idx = emojiIndexCache.get(host);
  if (!idx) return null;
  let found = idx.byExact.get(name) || idx.byLower.get(String(name).toLowerCase());
  return found?.url || null;
}
function makeResolvedKey(hostsArr, name) {
  return `${hostsArr.map(normHost).sort().join('|')}|${String(name||'').toLowerCase()}`;
}
function resolvedCacheSet(k, v) {
  resolvedEmojiCache.set(k, v);
  if (resolvedEmojiCache.size > 4000) {
    const it = resolvedEmojiCache.keys();
    for (let i=0;i<1000;i++){ const n = it.next(); if (n.done) break; resolvedEmojiCache.delete(n.value); }
  }
}
async function resolveEmojiAcrossHostsWithDebug(hosts, nameOrQualified) {
  const parsed = parseQualifiedEmoji(nameOrQualified);
  if (parsed.char) return { url: null, tried: [], reason: 'unicode' };

  const tried = [];
  const seen = new Set();
  const add = (h)=>{ const n=normHost(h||''); if(n && !seen.has(n)){ seen.add(n); tried.push(n); } };

  if (parsed.host) add(parsed.host);
  for (const h of hosts||[]) add(h);

  const cacheKey = makeResolvedKey(tried, parsed.name);
  if (resolvedEmojiCache.has(cacheKey)) {
    const url = resolvedEmojiCache.get(cacheKey);
    return { url, tried, hit: url ? '__cache__' : null, match: url ? 'cache' : null };
  }

  await Promise.all(tried.map(h => getMisskeyEmojis(h)));

  for (const h of tried) {
    const idx = emojiIndexCache.get(h);
    if (!idx) continue;
    let hit = idx.byExact.get(parsed.name);
    let match = 'exact';
    if (!hit) { hit = idx.byLower.get(String(parsed.name).toLowerCase()); match = hit ? 'loose' : null; }
    if (hit) {
      resolvedCacheSet(cacheKey, hit.url || null);
      return { url: hit.url || null, tried, hit: h, match };
    }
  }
  resolvedCacheSet(cacheKey, null);
  return { url: null, tried, reason: 'not_found' };
}

/* =========================
   Auto refresh (polling)
   ========================= */
let lastTopId = null;
let refreshTimer = null;

function getIdFromPost(item) { return item?.reblog?.id ?? item?.id ?? null; }
function startPolling() { if (!refreshTimer) refreshTimer = setInterval(checkForUpdates, 30000); }
function stopPolling() { if (refreshTimer) { clearInterval(refreshTimer); refreshTimer = null; } }

async function checkForUpdates() {
  try {
    if (!source || mode !== 'home' || !lastTopId) return;

    const base = source === 'masto' ? '/api/home' : '/api/mk/home';
    const url = new URL(base, location.origin);
    url.searchParams.set('merge', '0');
    url.searchParams.set('limit', '20');
    if (source === 'masto') url.searchParams.set('since_id', lastTopId);
    else url.searchParams.set('sinceId', lastTopId);

    const data = await jfetch(url.toString());
    const items = Array.isArray(data?.items) ? data.items : Array.isArray(data) ? data : [];
    if (!items.length) return;

    const toPrepend = [...items].reverse();

    for (const post of toPrepend) {
      const html = await renderPostHTML(post, { source });
      const wrapper = document.createElement('div');
      wrapper.innerHTML = html;
      const node = wrapper.firstElementChild;
      if (feedEl.firstChild) feedEl.insertBefore(node, feedEl.firstChild);
      else feedEl.appendChild(node);
    }

    const newest = toPrepend[toPrepend.length - 1];
    const newTopId = newest?.reblog?.id ?? newest?.id ?? null;
    if (newTopId) lastTopId = newTopId;

    try {
      for (let i = 0; i < toPrepend.length; i++) {
        const el = feedEl.children[i];
        el.style.transition = 'background-color .8s ease';
        el.style.backgroundColor = 'color-mix(in oklab, var(--link) 12%, var(--card))';
        setTimeout(() => { el.style.backgroundColor = ''; }, 50);
        setTimeout(() => { el.style.transition = ''; }, 900);
      }
    } catch {}

    const MAX_POSTS = 400;
    while (feedEl.children.length > MAX_POSTS) {
      feedEl.removeChild(feedEl.lastElementChild);
    }
  } catch (e) {
    console.warn('Auto refresh failed', e);
  }
}
document.addEventListener('visibilitychange', () => {
  if (document.hidden) stopPolling();
  else if (mode === 'home' && source === 'misskey') startPolling();
});


/* =========================
   Media rendering
   ========================= */
function renderMedia(post) {
  const media = Array.isArray(post?.media_attachments) ? post.media_attachments
               : Array.isArray(post?.files) ? post.files
               : [];
  if (!media.length) return '';
  const pieces = [];
  for (const m of media) {
    if (m?.type && (m.url || m.preview_url)) {
      if (m.type === 'image' || m.type === 'gifv') {
        pieces.push(`<img src="${m.preview_url || m.url}" loading="lazy" decoding="async" fetchpriority="low" alt="" />`);
      } else if (m.type === 'video') {
        pieces.push(`<video src="${m.url}" preload="metadata" controls playsinline></video>`);
      }
      continue;
    }
    if (m?.type && (m.url || m.thumbnailUrl)) {
      const isImage = String(m.type).startsWith('image/');
      if (isImage) pieces.push(`<img src="${m.thumbnailUrl || m.url}" loading="lazy" decoding="async" fetchpriority="low" alt="" />`);
      else pieces.push(`<video src="${m.url}" preload="metadata" controls playsinline></video>`);
      continue;
    }
    if (m?.url) pieces.push(`<img src="${m.url}" loading="lazy" decoding="async" fetchpriority="low" alt="" />`);
  }
  return pieces.length ? `<div class="media">${pieces.join('')}</div>` : '';
}

// 수집: 목록에서 이모지 호스트 후보 뽑기
function collectEmojiHostsFromItems(items) {
  const out = new Set();
  for (const st of items || []) {
    // 서버가 달아준 원글 호스트
    if (st?._mkHost) out.add(normHost(st._mkHost));

    // 계정 핸들 도메인
    const acc = (st?.reblog?.account) || st?.account;
    if (acc?.acct && acc.acct.includes('@')) out.add(normHost(acc.acct.split('@')[1]));

    // 리액션 안에 host 힌트가 있으면 추가
    const rxSrc = st?._mkReactions || [];
    for (const r of rxSrc) {
      if (r?.host && r.host !== '.') out.add(normHost(r.host));
      const q = (r?.qualified || r?.name || '').toString();
      const p = parseQualifiedEmoji(q);
      if (p.host) out.add(normHost(p.host));
    }
  }
  // 세션 호스트도 후보에
  if (activeHost) out.add(normHost(activeHost));
  return Array.from(out).filter(Boolean);
}

// 예열: 여러 호스트 이모지 리스트를 미리 요청 (동시성 제한)
const PREFETCH_MAX = 4;
async function prefetchEmojiHosts(hosts = []) {
  const list = Array.from(new Set(hosts.map(normHost))).filter(Boolean);
  let i = 0;
  const workers = Array.from({ length: Math.min(PREFETCH_MAX, list.length) }, async () => {
    while (i < list.length) {
      const h = list[i++]; 
      try { await getMisskeyEmojis(h); } catch {}
    }
  });
  await Promise.all(workers);
}


/* =========================
   Post card rendering
   ========================= */
const feedEl = document.getElementById('feed');
let myMastoId = null;
let myMkId = null;
let myAcct = null;
let mode = 'home';
let isLoading = false;
let cursor = null;
let source = null;
let activeHost = null;

function hasMastoCookies() { return !!getCookie('ap_token') && !!getCookie('ap_inst'); }
function hasMisskeyCookies() { return !!getCookie('mk_token') && !!getCookie('mk_host'); }

/* ---- 리액션 HTML 생성 분리 ---- */
async function buildReactionsHTMLForMasto({ base, post, isMine, faves, boosts, replies, activeHost }) {
  const debugObj = (base && base._mkDebug) || (post && post._mkDebug);

  function deriveMkReactionsFromRaw(debugObj) {
    const out = [];
    const raw = debugObj?.reactions_raw;
    if (!raw || typeof raw !== 'object') return out;
    for (const [key, cnt] of Object.entries(raw)) {
      const parsed = parseQualifiedEmoji(key);
      if (parsed.char) { out.push({ char: parsed.char, count: Number(cnt) || 0 }); continue; }
      if (parsed.name) { out.push({ name: parsed.name, host: parsed.host || null, count: Number(cnt) || 0 }); }
    }
    return out;
  }
  let mkReactions =
    (base && base._mkReactions) ||
    (post && post._mkReactions) ||
    deriveMkReactionsFromRaw(debugObj) || [];

  // 후보 호스트 수집
  const acc = base?.account || {};
  const deriveHost = () => {
    if (base && base._mkHost) return base._mkHost;
    if (post && post._mkHost) return post._mkHost;
    if (base && base._mkDebug?.host) return base._mkDebug.host;
    if (post && post._mkDebug?.host) return post._mkDebug.host;
    try { if (base && base._mkDebug?.apUri) return new URL(base._mkDebug.apUri).host; } catch {}
    try { if (post && post._mkDebug?.apUri) return new URL(post._mkDebug.apUri).host; } catch {}
    try { if (base?.url) return new URL(base.url).host; } catch {}
    try { if (base?.uri) return new URL(base.uri).host; } catch {}
    return null;
  };
  const mkHostGuess = deriveHost();

  const hostsToPrefetch = new Set();
  if (mkHostGuess) hostsToPrefetch.add(normHost(mkHostGuess));
  try {
    const acctDomain = (acc?.acct && acc.acct.includes('@')) ? acc.acct.split('@')[1] : null;
    if (acctDomain) hostsToPrefetch.add(normHost(acctDomain));
  } catch {}
  if (activeHost) hostsToPrefetch.add(normHost(activeHost));

  if (Array.isArray(mkReactions) && mkReactions.length) {
    for (const r of mkReactions) {
      const q = (r?.qualified ?? r?.name ?? '').toString();
      const p = parseQualifiedEmoji(q);
      const h1 = (r && typeof r.host === 'string' && r.host !== '.' && r.host) ? r.host : null;
      if (h1) hostsToPrefetch.add(normHost(h1));
      if (p.host) hostsToPrefetch.add(normHost(p.host));
    }
  }

  defer(() => prefetchEmojiHosts([...hostsToPrefetch]));

  const debugOn = new URL(location.href).searchParams.get('debug') === '1'
               || new URL(location.href).searchParams.get('debug') === '2';
  const debugRows = [];

  let reactionsHTML = '';
  if (Array.isArray(mkReactions)) {
    const pieces = await Promise.all(mkReactions.map(async (r) => {
      const q = (r?.qualified ?? r?.name ?? '').toString();
      const p = parseQualifiedEmoji(q);
      const cnt = (typeof r.count === 'number' && r.count > 0) ? r.count : (typeof r.count === 'number' ? '' : '');

      if (r?.url) {
        const alt = p.char ? p.char : (p.name ? `:${p.name}:` : (q || '❓'));
        return `<span class="rx-chip" role="img" aria-label="${p.name ? ':'+p.name+':' : (p.char || '')}">
          <img src="${r.url}" alt="${alt}" loading="lazy" decoding="async" fetchpriority="low" />
          ${cnt ? `<span class="meta" style="opacity:.7;margin-left:2px;">${cnt}</span>` : ''}
        </span>`;

      }
      if (p.char && !p.name) {
        return `<span class="rx-chip" role="img" aria-label="${p.name ? ':'+p.name+':' : (p.char || '')}">
          ${p.char ? p.char : (r.url ? `<img src="${r.url}" alt=":${p.name}:" loading="lazy" decoding="async" fetchpriority="low" />` : `:${p.name}:`)}
          ${cnt ? `<span class="meta" style="opacity:.7;margin-left:2px;">${cnt}</span>` : ''}
        </span>`;

      }
      if (p.name) {
        const candidates = new Set();
        if (p.host) candidates.add(normHost(p.host));
        for (const h of hostsToPrefetch) candidates.add(normHost(h));
        const { url, tried, hit, match } = await resolveEmojiAcrossHostsWithDebug([...candidates], q);
        if (url) {
          if (debugOn) debugRows.push({key:q, tried, hit, match, url});
          return `<span class="rx-chip" role="img" aria-label=":${p.name}:">
            <img src="${url}" alt=":${p.name}:" loading="lazy" decoding="async" fetchpriority="low" />
            ${cnt ? `<span class="meta" style="opacity:.7;margin-left:2px;">${cnt}</span>` : ''}
          </span>`;
        } else if (debugOn) {
          debugRows.push({key:q, tried, hit:null, match:null, url:null});
        }
      }
      const label = p.name ? `:${p.name}:` : (p.char ? p.char : (q || '❓'));
      return `<span class="rx-chip" role="img" aria-label="${label}">
        ${label}
        ${cnt ? `<span class="meta" style="opacity:.7;margin-left:2px;">${cnt}</span>` : ''}
      </span>`;

    }));
    reactionsHTML += pieces.join('');
  }

  const likeTargetId = base?.id || post?.id;
  reactionsHTML += `
    <button class="badge reply-toggle" data-id="${likeTargetId}" title="Show replies">💬 ${replies}</button>
    <span class="badge">♺ ${boosts}</span>
    <button class="badge ${isMine ? 'likers-toggle' : 'like-btn'}"
            data-id="${likeTargetId}"
            title="${isMine ? 'Show who liked' : 'Like'}">⭐ ${faves}</button>
  `;


  if (debugOn && debugRows.length) {
    reactionsHTML += `<div class="meta" style="margin-top:6px;overflow:auto">
      <table style="font-size:12px;border-collapse:collapse;border:1px dashed var(--border)">
        <thead><tr><th style="padding:4px 6px;border-bottom:1px dashed var(--border);text-align:left">key</th>
                   <th style="padding:4px 6px;border-bottom:1px dashed var(--border);text-align:left">hit</th>
                   <th style="padding:4px 6px;border-bottom:1px dashed var(--border);text-align:left">match</th>
                   <th style="padding:4px 6px;border-bottom:1px dashed var(--border);text-align:left">tried</th></tr></thead>
        <tbody>
          ${debugRows.map(r=>`<tr>
             <td style="padding:4px 6px;border-top:1px dashed var(--border)">${escapeHTML(r.key||'')}</td>
             <td style="padding:4px 6px;border-top:1px dashed var(--border)">${escapeHTML(r.hit||'')}</td>
             <td style="padding:4px 6px;border-top:1px dashed var(--border)">${escapeHTML(r.match||'')}</td>
             <td style="padding:4px 6px;border-top:1px dashed var(--border)">${(r.tried||[]).map(escapeHTML).join(', ')}</td>
          </tr>`).join('')}
        </tbody>
      </table>
    </div>`;
  }

  return reactionsHTML;
}

async function renderPostHTML(post, opts) {
  const { source } = opts;

  if (source === 'masto') {
    const isReblog = !!post?.reblog;
    const base = isReblog ? post.reblog : post;
    const booster = isReblog ? post.account : null;

    const isMine = !!myMastoId && base?.account?.id === myMastoId;

    const acc = base?.account || {};
    const displayName = acc.display_name || acc.username || '';
    const handle = acc.acct ? `@${acc.acct}` : '';
    const createdAt = base?.created_at || '';
    const avatarURL = acc.avatar_static || acc.avatar || '';

    const mastoEmojiMap = buildMastoEmojiMap(base);
    const rawContent = base?.content || '';
    const emojiHTML  = renderEmojisToHTML(rawContent, mastoEmojiMap);
    const { html: contentHTML, externalLinks } =
      transformContentAndCollectExternalLinks(emojiHTML, base, 'masto');
    const mediaHTML = renderMedia(base);

    // 🔗 링크 카드: 본문 HTML에서 URL 추출 → 스켈레톤 즉시, 실제 OG는 후순위
    const linkCardsHTML = await attachLinkCards({ base, post, source: 'masto', contentHTML });

    const faves = base?.favourites_count ?? 0;
    const boosts = base?.reblogs_count ?? 0;
    const replies = base?.replies_count ?? 0;

    const likeTargetId = base?.id || post?.id;

    const debugObj = (base && base._mkDebug) || (post && post._mkDebug);
    const debugOn = new URL(location.href).searchParams.get('debug') === '1'
                 || new URL(location.href).searchParams.get('debug') === '2';
    const debugHTML = (debugOn && debugObj)
      ? `<pre class="meta" style="white-space:pre-wrap;margin-top:8px;border:1px dashed var(--border);padding:8px;border-radius:8px;opacity:0.8;">_mkDebug: ${escapeHTML(JSON.stringify(debugObj, null, 2))}</pre>`
      : '';

    const card = (htmlHead, inner) => `
      ${htmlHead}
      ${mediaHTML}
      ${linkCardsHTML}
      <div class="reactions">
        <div class="rx-list" id="rx-${likeTargetId}"></div>
        <div class="rx-actions" id="ax-${likeTargetId}"></div>
      </div>

      <!-- ✅ 댓글 입력창(초기 닫힘, 슬라이드다운) -->
      <div class="composer" data-for="${likeTargetId}" hidden>
        <form class="reply-form" data-id="${likeTargetId}">
          <textarea placeholder="답글 작성…"></textarea>
          <div class="row">
            <button type="submit" class="btn">보내기</button>
            <span class="meta">Ctrl/Cmd+Enter 전송</span>
          </div>
        </form>
      </div>
      ${debugHTML}
      <div class="thread" data-for="${likeTargetId}" hidden></div>
    `;

    // 리액션은 후순위로 채움
    scheduleReactionTask(async () => {
      try {
        const container = document.getElementById(`rx-${likeTargetId}`);
        if (!container) return;
        const reactionsHTML = await buildReactionsHTMLForMasto({
          base, post, isMine, faves, boosts, replies, activeHost
        });
        container.innerHTML = reactionsHTML;
      } catch {}
    });

    if (isReblog) {
      const boosterName = booster?.display_name || booster?.username || '';
      const boosterHandle = booster?.acct ? `@${booster.acct}` : '';
      const boosterAvatar = booster?.avatar_static || booster?.avatar || '';

      return `
        <article class="post reblog" data-post-id="${likeTargetId}">
          <div class="reblog-banner">
            <span class="icon">↻</span>
            <span class="user-chip">
              <img class="avatar-mini" src="${boosterAvatar}" alt="" loading="lazy" decoding="async" fetchpriority="low">
              <strong>${escapeHTML(boosterName)}</strong> <span class="meta">${escapeHTML(boosterHandle)}</span>
            </span>
            <span class="meta">님이 부스트했습니다</span>
          </div>
          <div class="reblog-inner">
            <div class="post-head">
              <img class="avatar" src="${avatarURL}" alt="" loading="lazy" decoding="async" fetchpriority="low">
              <div>
                <div class="name">${renderEmojisToHTML(escapeHTML(displayName), mastoEmojiMap)} <span class="meta">${escapeHTML(handle)}</span></div>
                <div class="meta">${new Date(createdAt).toLocaleString()}</div>
              </div>
            </div>
            <div class="content">${contentHTML}</div>
            ${card('', '')}
          </div>
        </article>
      `;
    }

    return `
      <article class="post" data-post-id="${likeTargetId}">
        <div class="post-head">
          <img class="avatar" src="${avatarURL}" alt="" loading="lazy" decoding="async" fetchpriority="low">
          <div>
            <div class="name">${renderEmojisToHTML(escapeHTML(displayName), mastoEmojiMap)} <span class="meta">${escapeHTML(handle)}</span></div>
            <div class="meta">${new Date(createdAt).toLocaleString()}</div>
          </div>
        </div>
        <div class="content">${contentHTML}</div>
        ${card('', '')}
      </article>
    `;
  }

  // ===== Misskey 타임라인 =====
  if (source === 'misskey') {
    const u = post?.user || {};
    const displayName = u.name || u.username || '';
    const handle = u.username ? `@${u.username}` : '';
    const createdAt = post?.createdAt || '';
    const avatarURL = u.avatarUrl || '';
    const host = getCookie('mk_host');

    const emojiList = await getMisskeyEmojis(host);
    const text = post?.text || '';
    const textHTML = renderEmojisToHTML(escapeHTML(text).replace(/\n/g, '<br>'), emojiList);
    // ✅ 추가: 평문 멘션을 칩으로 마킹(초기엔 아바타 없이)
    textHTML = chipifyPlainMentions(textHTML);
    // ✅ 2. content 블록 id 생성
    const contentId = `cnt-${post?.id || Math.random().toString(36).slice(2)}`;
    const mediaHTML = renderMedia(post);

    // 🔗 링크 카드: Misskey는 평문에서 URL 추출
    const linkCardsHTML = await attachLinkCards({ base: null, post, source: 'misskey', contentHTML: textHTML });

    // ✅ 3. 이 시점에 “DOM 붙은 뒤 실행” 스케줄
    defer(() => hydrateMisskeyMentions(contentId));


    const rx = post?.reactions || {};
    const rxBadges = [];
    if (rx && typeof rx === 'object') {
      const postHost =
        (post?._mkDebug && post._mkDebug.host) ||
        (() => { try { return new URL(post?.url || post?.uri || '').host } catch { return null } })() ||
        host;
      for (const key of Object.keys(rx)) {
        const count = rx[key];
        const parsed = parseQualifiedEmoji(key);
        if (parsed.char) {
          rxBadges.push(`<span class="rx-chip" role="img" aria-label="${parsed.char}">
            ${parsed.char}
            <span class="meta" style="opacity:.7;margin-left:2px;">${count}</span>
          </span>`);
          continue;
        }
        let em = (emojiIndexCache.get(normHost(host))?.byExact.get(parsed.name))
              || (emojiIndexCache.get(normHost(host))?.byLower.get(String(parsed.name).toLowerCase()));
        if (!em && parsed.host) {
          await getMisskeyEmojis(parsed.host);
          const idx = emojiIndexCache.get(normHost(parsed.host));
          em = idx?.byExact.get(parsed.name) || idx?.byLower.get(String(parsed.name).toLowerCase());
        }
        if (!em && postHost) {
          await getMisskeyEmojis(postHost);
          const idx = emojiIndexCache.get(normHost(postHost));
          em = idx?.byExact.get(parsed.name) || idx?.byLower.get(String(parsed.name).toLowerCase());
        }
        if (em?.url) rxBadges.push(`<span class="rx-chip" role="img" aria-label=":${parsed.name}:">
          <img src="${em.url}" alt=":${parsed.name}:" loading="lazy" decoding="async" fetchpriority="low" />
          <span class="meta" style="opacity:.7;margin-left:2px;">${count}</span>
        </span>`);
      }
    }

    return `
      <article class="post">
        <div class="post-head">
          <img class="avatar" src="${avatarURL}" alt="" loading="lazy" decoding="async" fetchpriority="low">
          <div>
            <div class="name">${renderEmojisToHTML(escapeHTML(displayName), emojiList)} <span class="meta">${escapeHTML(handle)}</span></div>
            <div class="meta">${new Date(createdAt).toLocaleString()}</div>
          </div>
        </div>
        <div class="content" id="${contentId}">${textHTML}</div>
        ${mediaHTML}
        ${linkCardsHTML}
        <div class="reactions">${rxBadges.join('')}</div>
      </article>
    `;
  }

  return `<article class="post"><div class="content">Unsupported post</div></article>`;
}


/* =========================
   Timeline state & loaders
   ========================= */
let pageAborter = null;

async function loadMe() {
  const preferMasto = hasMastoCookies();
  const preferMisskey = hasMisskeyCookies();

  const tryMasto = async () => {
    const me = await jfetch('/api/me');
    source = 'masto';
    activeHost = getCookie('ap_inst') || '';

    const display = me?.display_name || me?.username || '';
    const handle  = me?.acct ? `@${me.acct}` : (me?.username ? `@${me.username}` : '');
    const avatar  = me?.avatar_static || me?.avatar || '';

    const list = Array.isArray(me?.emojis)
      ? me.emojis.map(e => {
          const name = e?.shortcode || e?.name;
          const url  = e?.url;
          return (name && url) ? { name, url } : null;
        }).filter(Boolean)
      : [];

    const nameEl = document.getElementById('acct-name');
    const avEl   = document.getElementById('acct-avatar');

    if (nameEl) {
      nameEl.innerHTML =
        `${renderEmojisToHTML(escapeHTML(display), list)} <span class="meta">${escapeHTML(handle)}</span>`;
    }
    if (avEl && avatar) avEl.src = avatar;

    myMastoId = me?.id || null;
    myAcct = me?.acct || null;
    return 'masto';
  };
  const tryMisskey = async () => {
    const me = await jfetch('/api/mk/me');
    source = 'misskey';
    activeHost = getCookie('mk_host') || '';

    const display = me?.name || me?.username || '';
    const handle  = me?.username ? `@${me.username}` : '';
    const avatar  = me?.avatarUrl || me?.avatar || '';

    const nameEl = document.getElementById('acct-name');
    const avEl   = document.getElementById('acct-avatar');

    if (nameEl) {
      nameEl.innerHTML =
        `${escapeHTML(display)} <span class="meta">${escapeHTML(handle)}</span>`;
    }
    if (avEl && avatar) avEl.src = avatar;

    myMkId = me?.id || null;
    return 'misskey';
  };

  try {
    if (preferMasto) return await tryMasto();
    if (preferMisskey) return await tryMisskey();
    return await tryMasto();
  } catch {
    try {
      if (source !== 'misskey') return await tryMisskey();
      return await tryMasto();
    } catch (e) {
      source = null;
      alert('세션이 만료되었거나 로그인 정보가 없습니다. 다시 로그인해 주세요.');
      location.href = '/';
      throw e;
    }
  }
}

let io;

async function loadPage(initial=false) {
  if (isLoading || !source) return;
  isLoading = true;

  // 이전 요청 취소
  if (pageAborter) pageAborter.abort();
  pageAborter = new AbortController();

  try {
    const path =
      mode === 'fav'
        ? (source === 'masto' ? '/api/favourites' : '/api/mk/home?favourites=1')
        : mode === 'mine'
          ? (source === 'masto' ? '/api/mine' : '/api/mk/mine')
          : (source === 'masto' ? '/api/home' : '/api/mk/home');

    const u = new URL(path, location.origin);
    u.searchParams.set('limit', '20');
    if (cursor) {
      source === 'masto' ? u.searchParams.set('max_id', cursor)
                        : u.searchParams.set('untilId', cursor);
    }
    // 🚀 첫 페이지는 합성 작업에 시간 예산/스코프를 좁혀서 "먼저 빨리 보여주기"
    if (initial) {
      u.searchParams.set('merge', '1');          // 합성은 켜두되
      u.searchParams.set('merge_limit', '3');    // 상단 몇 개만
      u.searchParams.set('mk_budget_ms', '900'); // 서버 합성 총 예산 900ms
      u.searchParams.set('mk_prefetch', '0');    // 호스트 메타 프리페치 스킵(아래 서버 코드와 연결)
    } else {
      // 이후 페이지는 합성 끄고 스크롤 속도 우선
      u.searchParams.set('merge', '0');
    }
    if (new URL(location.href).searchParams.get('debug') === '1' ||
        new URL(location.href).searchParams.get('debug') === '2') {
      u.searchParams.set('debug', '1');
    }

    const data = await jfetch(u.toString(), { signal: pageAborter.signal });
    if (mode === 'home') {
      const top = Array.isArray(data?.items) ? data.items[0] : Array.isArray(data) ? data[0] : null;
      lastTopId = top ? (top?.reblog?.id ?? top?.id ?? null) : lastTopId;
    }

    const rawItems = Array.isArray(data?.items) ? data.items : Array.isArray(data) ? data : [];
    let items = rawItems;

    defer(() => prefetchEmojiHosts(collectEmojiHostsFromItems(items)));

    const frag = document.createDocumentFragment();
    const placeholders = items.map(() => {
      const ph = document.createElement('article');
      ph.className = 'post';
      ph.innerHTML = '<div class="meta">Loading…</div>';
      frag.appendChild(ph);
      return ph;
    });
    feedEl.appendChild(frag);

    await Promise.all(items.map(async (post, i) => {
      try {
        const html = await renderPostHTML(post, { source });
        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;
        placeholders[i].replaceWith(wrapper.firstElementChild);
      } catch (e) {
        placeholders[i].innerHTML = '<div class="meta">Failed to render</div>';
      }
    }));

    cursor = (source === 'masto')
      ? (data?.next_max_id || (rawItems.length ? rawItems[rawItems.length-1]?.id : null))
      : (data?.next || (rawItems.length ? rawItems[rawItems.length-1]?.id : null));
  } catch (e) {
    if (e?.name === 'AbortError') {
      // 최신 요청이 이전 요청을 취소함: 조용히 반환
    } else if (e?.status === 401) {
      if (source === 'misskey' && hasMastoCookies()) {
        console.warn('Misskey 401: Mastodon으로 자동 전환합니다.');
        source = 'masto'; cursor = null; feedEl.innerHTML = '';
        await loadPage(true);
      } else {
        alert('세션이 만료되었습니다. 다시 로그인해 주세요.');
        if (io?.disconnect) io.disconnect();
      }
    } else {
      console.error(e);
    }
  } finally {
    isLoading = false;
  }
}

async function autofillIfNeeded(maxLoops = 3) {
  for (let i = 0; i < maxLoops; i++) {
    const sentinel = document.getElementById('sentinel');
    if (!sentinel) break;
    const rect = sentinel.getBoundingClientRect();
    if (rect.top < window.innerHeight + 400) {
      await loadPage();
      await new Promise(r => setTimeout(r, 0)); // 메인스레드 양보
    } else {
      break;
    }
  }
}

/* =========================
   Realtime streaming (SSE)
   ========================= */
let es = null;
const seenIds = new Set();
function postKey(item) { return item?.reblog?.id ?? item?.id ?? null; }

async function prependStatus(st) {
  const key = postKey(st);
  if (!key) return;
  if (seenIds.has(key)) return;
  seenIds.add(key);
  if (seenIds.size > 5000) { for (const k of seenIds) { seenIds.delete(k); if (seenIds.size <= 2500) break; } }

  const html = await renderPostHTML(st, { source: 'masto' });
  const wrap = document.createElement('div');
  wrap.innerHTML = html;
  const node = wrap.firstElementChild;
  if (!node) return;

  node.style.position = 'absolute';
  node.style.visibility = 'hidden';
  node.style.pointerEvents = 'none';
  feedEl.insertBefore(node, feedEl.firstChild || null);
  const h = node.getBoundingClientRect().height || 0;
  node.style.position = ''; node.style.visibility = ''; node.style.pointerEvents = '';

  const spacer = document.createElement('div');
  spacer.className = 'new-spacer';
  spacer.style.height = h + 'px';
  feedEl.insertBefore(spacer, node);

  node.classList.add('slide-enter');
  node.getBoundingClientRect();
  node.classList.add('slide-enter-active');
  requestAnimationFrame(() => { spacer.style.height = '0px'; });

  const done = () => {
    node.classList.remove('slide-enter', 'slide-enter-active');
    spacer.remove();
    node.removeEventListener('transitionend', done);
  };
  node.addEventListener('transitionend', done, { once: true });

  if (!feedEl.firstElementChild) feedEl.appendChild(node);
}
function startStream() {
  if (es || source !== 'masto') return;
  es = new EventSource('/api/stream/user', { withCredentials: true });
  es.addEventListener('open', () => {});
  es.addEventListener('error', () => {});
  es.addEventListener('update', async (evt) => {
    if (mode !== 'home') return;
    try {
      const st = JSON.parse(evt.data);
      await prependStatus(st);
      lastTopId = postKey(st) || lastTopId;
    } catch {}
  });
  es.addEventListener('delete', (evt) => {
    const id = evt.data?.trim();
    if (!id) return;
    seenIds.delete(id);
    const article = feedEl.querySelector(`.post .like-btn[data-id="${CSS.escape(id)}"]`)?.closest('article');
    if (article) article.remove();
  });
}
function stopStream() { if (!es) return; try { es.close(); } catch {} es = null; }

/* =========================
   UI bindings
   ========================= */
document.getElementById('tab-home').addEventListener('click', async () => {
  mode = 'home';
  cursor = null;
  feedEl.innerHTML = '';
  await loadPage(true);
  await autofillIfNeeded();
  if (source === 'masto') startStream();
  else if (source === 'misskey') startPolling();
});
document.getElementById('tab-fav').addEventListener('click', async () => {
  mode = 'fav';
  stopPolling();
  cursor = null; feedEl.innerHTML = '';
  await loadPage(true); await autofillIfNeeded();
});
document.addEventListener('click', async (ev) => {
  const btn = ev.target.closest?.('#acct-btn');
  if (!btn) return;
  mode = 'mine';
  stopStream(); stopPolling();
  cursor = null; feedEl.innerHTML = '';
  await loadPage(true);
  await autofillIfNeeded();
});
document.getElementById('logout').addEventListener('click', async () => {
  try {
    if (source === 'masto') await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
    if (source === 'misskey') await fetch('/api/mk/logout', { method: 'POST', credentials: 'include' });
  } finally {
    location.href = '/';
  }
});

// 💬 댓글 토글
const threadCache = new Map();
document.addEventListener('click', async (ev) => {
  const btn = ev.target.closest('.reply-toggle');
  if (!btn) return;

  if (source !== 'masto') {
    alert('Misskey 대화 보기는 준비 중이에요!');
    return;
  }

  const id = btn.dataset.id;
  if (!id) return;

  const article = btn.closest('article');
  let threadEl = article?.querySelector(`.thread[data-for="${CSS.escape(id)}"]`);
  if (!threadEl) threadEl = document.querySelector(`.thread[data-for="${CSS.escape(id)}"]`);
  if (!threadEl) return;

  if (!threadEl.hasAttribute('hidden')) {
    threadEl.setAttribute('hidden', '');
    btn.title = 'Show replies';
    return;
  }

  if (threadCache.has(id)) {
    threadEl.innerHTML = threadCache.get(id);
    threadEl.removeAttribute('hidden');
    btn.title = 'Hide replies';
    return;
  }

  threadEl.innerHTML = `<div class="meta">불러오는 중…</div>`;
  threadEl.removeAttribute('hidden');

  try {
    const data = await jfetch(`/api/status/context?id=${encodeURIComponent(id)}`);
    const desc = Array.isArray(data?.descendants) ? data.descendants : [];
    if (!desc.length) {
      threadEl.innerHTML = `<div class="meta">대화가 없습니다.</div>`;
      threadCache.set(id, threadEl.innerHTML);
      btn.title = 'Hide replies';
      return;
    }

    desc.sort((a,b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());

    const parts = [];
    for (const st of desc) {
      try {
        const html = await renderPostHTML(st, { source: 'masto' });
        parts.push(html);
      } catch {}
    }
    const htmlAll = parts.join('');
    threadEl.innerHTML = htmlAll || `<div class="meta">표시할 대화가 없습니다.</div>`;
    threadCache.set(id, threadEl.innerHTML);
    btn.title = 'Hide replies';
  } catch (e) {
    console.error('context fetch error', e);
    threadEl.innerHTML = `<div class="meta">대화를 불러오지 못했습니다.</div>`;
  }
});

// ⭐ 좋아요
document.addEventListener('click', async (ev) => {
  const btn = ev.target.closest('.like-btn');
  if (!btn) return;

  const id = btn.dataset.id;
  if (!id) { console.error('like: missing data-id'); return; }

  const orig = btn.textContent || '⭐ 0';

  btn.disabled = true;
  btn.textContent = '⭐…';
  try {
    const res = await fetch('/api/like', {
      method: 'POST',
      credentials: 'include',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ id })
    });

    let payload = null;
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) payload = await res.json().catch(() => null);
    else payload = await res.text().catch(() => '');

    if (!res.ok) {
      console.error('like failed', res.status, payload);
      btn.textContent = '⭐!';
      btn.title = res.status === 401 ? 'Mastodon 로그인 필요(세션 만료)' : `Like failed: ${res.status}`;
      return;
    }

    let newCount;
    if (payload && typeof payload.favourites_count === 'number') newCount = payload.favourites_count;
    else {
      const m = (orig.match(/^⭐\s*(\d+)/));
      const cur = m ? parseInt(m[1], 10) : 0;
      newCount = cur + 1;
    }

    btn.textContent = `⭐ ${newCount}`;
    btn.title = 'Liked!';
    btn.style.background = 'var(--btn-bg-hover)';

  } catch (e) {
    console.error('like error', e);
    btn.textContent = '⭐×';
    btn.title = 'Network error';
  } finally {
    btn.disabled = false;
  }
});

document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

// 댓글 링크 클릭 → 컴포저 열고 @계정 프리필
document.addEventListener('click', (ev) => {
  const a = ev.target.closest('.mention-reply');
  if (!a) return;
  ev.preventDefault();

  // 소속 포스트 id 찾기
  const article = a.closest('article');
  if (!article) return;
  const likeBtn = article.querySelector('.like-btn, .reply-toggle');
  const postId = likeBtn?.dataset.id || article.getAttribute('data-post-id');
  if (!postId) return;

  const composer = article.querySelector(`.composer[data-for="${CSS.escape(postId)}"]`);
  if (!composer) return;

  // 열기 애니메이션
  if (composer.hasAttribute('hidden')) composer.removeAttribute('hidden');
  composer.classList.add('open');

  const ta = composer.querySelector('textarea');
  const acct = a.dataset.replyAcct || '';
  if (ta) {
    // 이미 같은 멘션이 없으면 프리펜드
    if (acct && !ta.value.includes(acct)) {
      ta.value = (acct + ' ' + ta.value).trim() + ' ';
    }
    ta.focus();
    // 커서 끝
    ta.selectionStart = ta.selectionEnd = ta.value.length;
  }
});

// Ctrl/Cmd+Enter 전송
document.addEventListener('keydown', (ev) => {
  if ((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter') {
    const form = ev.target.closest?.('.reply-form');
    if (form) form.requestSubmit();
  }
});

// 전송 핸들러(백엔드 엔드포인트에 맞게 조정)
document.addEventListener('submit', async (ev) => {
  const form = ev.target.closest('.reply-form');
  if (!form) return;
  ev.preventDefault();

  const id = form.getAttribute('data-id');
  const ta = form.querySelector('textarea');
  const text = (ta?.value || '').trim();
  if (!id || !text) return;

  const btn = form.querySelector('button[type="submit"]');
  if (btn){ btn.disabled = true; btn.textContent = '전송 중…'; }

  try {
    // ⚠️ 서버에 맞게 경로/필드명 조정 (/api/reply 가정)
    const res = await fetch('/api/reply', {
      method: 'POST',
      credentials: 'include',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ id, status: text })
    });
    if (!res.ok) throw new Error('reply failed: ' + res.status);

    // 성공: 비우고 닫기
    if (ta) ta.value = '';
    const composer = form.closest('.composer');
    if (composer) {
      composer.classList.remove('open');
      composer.setAttribute('hidden','');
    }
  } catch (e) {
    console.error(e);
    alert('댓글 전송에 실패했어요.');
  } finally {
    if (btn){ btn.disabled = false; btn.textContent = '보내기'; }
  }
});

// infinite scroll (루트 마진 상향 + 쿨다운)
let ioLock = false;
io = new IntersectionObserver(async (entries) => {
  for (const e of entries) {
    if (e.isIntersecting) {
      if (ioLock) return;
      ioLock = true;
      await loadPage();
      setTimeout(() => { ioLock = false; }, 150);
    }
  }
}, { rootMargin: '1200px' });
io.observe(document.getElementById('sentinel'));

// ===== Lightweight Profiler (toggle with ?prof=1) =====
const PROF_ON = new URL(location.href).searchParams.get('prof') === '1';
const PROF = {
  t: {},    // named timers
  sums: { batchRender:0, batchCount:0, rxTotal:0, rxCount:0, emojiFetchMs:0, emojiHits:0, emojiMiss:0 },
  lastFetchMs: null,
  lastServerMergeMs: null,
  lastServerCounters: null,
};
function tick(name){ PROF.t[name] = performance.now(); }
function tock(name){ const v = performance.now() - (PROF.t[name]||performance.now()); delete PROF.t[name]; return v; }

// HUD
let hud, fps=0, rafId;
function startHUD(){
  if (!PROF_ON) return;
  hud = document.createElement('div');
  hud.style.cssText = `
    position:fixed;right:10px;bottom:10px;z-index:99999;
    background:color-mix(in oklab, var(--card) 92%, transparent);
    border:1px solid var(--border); padding:8px 10px; border-radius:10px;
    font:12px/1.35 system-ui; color:var(--fg); box-shadow:var(--shadow);
    max-width:320px; white-space:nowrap;`;
  document.body.appendChild(hud);

  // FPS
  let frames = 0, last = performance.now();
  function loop(){
    frames++;
    const now = performance.now();
    if (now - last >= 1000){ fps = frames; frames = 0; last = now; drawHUD(); }
    rafId = requestAnimationFrame(loop);
  }
  loop();
}
function drawHUD(){
  if (!hud) return;
  const s = PROF.sums;
  const avgCard = s.batchCount ? (s.batchRender / s.batchCount) : 0;
  const avgRx   = s.rxCount ? (s.rxTotal / s.rxCount) : 0;
  hud.innerHTML = `
    <div style="font-weight:700;margin-bottom:4px">Perf HUD</div>
    <div>FPS: <b>${fps}</b></div>
    <div>Fetch: <b>${Math.round(PROF.lastFetchMs||0)}ms</b>
      ${PROF.lastServerMergeMs!=null ? ` | serverMerge <b>${PROF.lastServerMergeMs}</b>ms` : ''}</div>
    <div>Render(batch): <b>${Math.round(s.batchRender)}ms</b> / ${s.batchCount} cards (avg <b>${Math.round(avgCard)}ms</b>)</div>
    <div>Reactions: <b>${Math.round(s.rxTotal)}ms</b> / ${s.rxCount} cards (avg <b>${Math.round(avgRx)}ms</b>)</div>
    <div>EmojiList: <b>${Math.round(s.emojiFetchMs)}ms</b> (hit ${s.emojiHits} / miss ${s.emojiMiss})</div>
    <div style="margin-top:4px;opacity:.75">${PROF.lastServerCounters ? escapeHTML(PROF.lastServerCounters) : ''}</div>
  `;
}
if (PROF_ON) startHUD();

// patch jfetch to measure TTFB + server headers
const _jfetch = jfetch;
jfetch = async function(url, opts={}){
  if (!PROF_ON) return _jfetch(url, opts);
  tick('fetch');
  const r = await fetch(url, { credentials:'include', ...opts });
  const ms = tock('fetch');
  PROF.lastFetchMs = ms;
  PROF.lastServerMergeMs = Number(r.headers.get('x-mk-merge-ms') || '') || null;
  const counters = r.headers.get('x-mk-merge-summary') || r.headers.get('x-mk-merge-counters');
  PROF.lastServerCounters = counters;
  const ct = r.headers.get('content-type') || '';
  const body = ct.includes('application/json') ? await r.json() : await r.text();
  if (!r.ok) {
    const err = new Error(`${r.status} ${r.statusText}`); err.status=r.status; err.body=body; throw err;
  }
  drawHUD();
  return body;
};

// measure Misskey emoji list fetch hit/miss
const _getMisskeyEmojis = getMisskeyEmojis;
getMisskeyEmojis = async function(host){
  if (!PROF_ON) return _getMisskeyEmojis(host);
  const hasLS = !!lsLoadEmoji(normHost(host||''));
  if (!hasLS) tick('emojiFetch');
  const res = await _getMisskeyEmojis(host);
  if (!hasLS){
    PROF.sums.emojiFetchMs += tock('emojiFetch');
    PROF.sums.emojiMiss++;
  } else {
    PROF.sums.emojiHits++;
  }
  drawHUD();
  return res;
};

// wrap renderPostHTML to time per-batch cost
const _renderPostHTML = renderPostHTML;
renderPostHTML = async function(post, opts){
  if (!PROF_ON) return _renderPostHTML(post, opts);
  tick('card');
  const html = await _renderPostHTML(post, opts);
  const dt = tock('card');
  PROF.sums.batchRender += dt;
  PROF.sums.batchCount++;
  drawHUD();
  return html;
};

// wrap buildReactionsHTMLForMasto to time reaction building
const _buildRx = buildReactionsHTMLForMasto;
buildReactionsHTMLForMasto = async function(args){
  if (!PROF_ON) return _buildRx(args);
  tick('rx');
  const h = await _buildRx(args);
  const dt = tock('rx');
  PROF.sums.rxTotal += dt;
  PROF.sums.rxCount++;
  drawHUD();
  return h;
};

// init
(async function init() {
  await loadMe();
  await loadPage(true);
  await autofillIfNeeded();

  if (mode === 'home') {
    if (source === 'masto') startStream();
    else if (source === 'misskey') startPolling();
  }
})();
</script>
</body>
</html>